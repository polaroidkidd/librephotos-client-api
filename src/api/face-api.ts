/* tslint:disable */
/* eslint-disable */
/**
 * LibrePhotos
 * Your project description
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { IFace } from '../models';
// @ts-ignore
import { IFaceList } from '../models';
// @ts-ignore
import { IPaginatedFaceList } from '../models';
// @ts-ignore
import { IPaginatedFaceListList } from '../models';
// @ts-ignore
import { IPatchedFace } from '../models';
// @ts-ignore
import { IPatchedFaceList } from '../models';
/**
 * FaceApi - axios parameter creator
 * @export
 */
export const FaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesCreate: async (iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesCreate', 'iFace', iFace)
            const localVarPath = `/api/faces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesDestroy', 'id', id)
            const localVarPath = `/api/faces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredCreate: async (iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesInferredCreate', 'iFace', iFace)
            const localVarPath = `/api/faces/inferred/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredDestroy', 'id', id)
            const localVarPath = `/api/faces/inferred/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/inferred/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListCreate: async (iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesInferredListCreate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/inferred/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredListDestroy', 'id', id)
            const localVarPath = `/api/faces/inferred/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/inferred/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListPartialUpdate: async (id: string, iPatchedFaceList?: IPatchedFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredListPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/inferred/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredListRetrieve', 'id', id)
            const localVarPath = `/api/faces/inferred/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListUpdate: async (id: string, iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredListUpdate', 'id', id)
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesInferredListUpdate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/inferred/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredPartialUpdate: async (id: string, iPatchedFace?: IPatchedFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/inferred/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredRetrieve', 'id', id)
            const localVarPath = `/api/faces/inferred/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredUpdate: async (id: string, iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesInferredUpdate', 'id', id)
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesInferredUpdate', 'iFace', iFace)
            const localVarPath = `/api/faces/inferred/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledCreate: async (iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesLabeledCreate', 'iFace', iFace)
            const localVarPath = `/api/faces/labeled/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledDestroy', 'id', id)
            const localVarPath = `/api/faces/labeled/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/labeled/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListCreate: async (iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesLabeledListCreate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/labeled/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledListDestroy', 'id', id)
            const localVarPath = `/api/faces/labeled/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/labeled/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListPartialUpdate: async (id: string, iPatchedFaceList?: IPatchedFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledListPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/labeled/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledListRetrieve', 'id', id)
            const localVarPath = `/api/faces/labeled/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListUpdate: async (id: string, iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledListUpdate', 'id', id)
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesLabeledListUpdate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/labeled/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledPartialUpdate: async (id: string, iPatchedFace?: IPatchedFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/labeled/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledRetrieve', 'id', id)
            const localVarPath = `/api/faces/labeled/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledUpdate: async (id: string, iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesLabeledUpdate', 'id', id)
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesLabeledUpdate', 'iFace', iFace)
            const localVarPath = `/api/faces/labeled/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListCreate: async (iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesListCreate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListDestroy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesListDestroy', 'id', id)
            const localVarPath = `/api/faces/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListList: async (page?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/faces/list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListPartialUpdate: async (id: string, iPatchedFaceList?: IPatchedFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesListPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesListRetrieve', 'id', id)
            const localVarPath = `/api/faces/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListUpdate: async (id: string, iFaceList: IFaceList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesListUpdate', 'id', id)
            // verify required parameter 'iFaceList' is not null or undefined
            assertParamExists('apiFacesListUpdate', 'iFaceList', iFaceList)
            const localVarPath = `/api/faces/list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFaceList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesPartialUpdate: async (id: number, iPatchedFace?: IPatchedFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesPartialUpdate', 'id', id)
            const localVarPath = `/api/faces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iPatchedFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesRetrieve', 'id', id)
            const localVarPath = `/api/faces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesUpdate: async (id: number, iFace: IFace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFacesUpdate', 'id', id)
            // verify required parameter 'iFace' is not null or undefined
            assertParamExists('apiFacesUpdate', 'iFace', iFace)
            const localVarPath = `/api/faces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iFace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFullscanphotosRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/fullscanphotos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLabelfacesCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/labelfaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FaceApi - functional programming interface
 * @export
 */
export const FaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesCreate(iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesCreate(iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredCreate(iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredCreate(iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListCreate(iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListPartialUpdate(id, iPatchedFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredListUpdate(id, iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredPartialUpdate(id, iPatchedFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesInferredUpdate(id: string, iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesInferredUpdate(id, iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledCreate(iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledCreate(iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListCreate(iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListPartialUpdate(id, iPatchedFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledListUpdate(id, iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledPartialUpdate(id, iPatchedFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesLabeledUpdate(id: string, iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesLabeledUpdate(id, iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListCreate(iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListDestroy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListList(page?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPaginatedFaceListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListPartialUpdate(id, iPatchedFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesListUpdate(id, iFaceList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesPartialUpdate(id: number, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesPartialUpdate(id, iPatchedFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFacesUpdate(id: number, iFace: IFace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IFace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFacesUpdate(id, iFace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFullscanphotosRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFullscanphotosRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLabelfacesCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLabelfacesCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FaceApi - factory interface
 * @export
 */
export const FaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FaceApiFp(configuration)
    return {
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesCreate(iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesCreate(iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredCreate(iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesInferredCreate(iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesInferredDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceList> {
            return localVarFp.apiFacesInferredList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListCreate(iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesInferredListCreate(iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesInferredListDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceListList> {
            return localVarFp.apiFacesInferredListList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesInferredListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListRetrieve(id: string, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesInferredListRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredListUpdate(id: string, iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesInferredListUpdate(id, iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesInferredPartialUpdate(id, iPatchedFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredRetrieve(id: string, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesInferredRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesInferredUpdate(id: string, iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesInferredUpdate(id, iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledCreate(iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesLabeledCreate(iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesLabeledDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceList> {
            return localVarFp.apiFacesLabeledList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListCreate(iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesLabeledListCreate(iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesLabeledListDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceListList> {
            return localVarFp.apiFacesLabeledListList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesLabeledListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListRetrieve(id: string, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesLabeledListRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledListUpdate(id: string, iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesLabeledListUpdate(id, iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesLabeledPartialUpdate(id, iPatchedFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledRetrieve(id: string, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesLabeledRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesLabeledUpdate(id: string, iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesLabeledUpdate(id, iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceList> {
            return localVarFp.apiFacesList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListCreate(iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesListCreate(iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListDestroy(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiFacesListDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListList(page?: number, pageSize?: number, options?: any): AxiosPromise<IPaginatedFaceListList> {
            return localVarFp.apiFacesListList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IPatchedFaceList} [iPatchedFaceList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListRetrieve(id: string, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesListRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {IFaceList} iFaceList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesListUpdate(id: string, iFaceList: IFaceList, options?: any): AxiosPromise<IFaceList> {
            return localVarFp.apiFacesListUpdate(id, iFaceList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IPatchedFace} [iPatchedFace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesPartialUpdate(id: number, iPatchedFace?: IPatchedFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesPartialUpdate(id, iPatchedFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesRetrieve(id: number, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this face.
         * @param {IFace} iFace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFacesUpdate(id: number, iFace: IFace, options?: any): AxiosPromise<IFace> {
            return localVarFp.apiFacesUpdate(id, iFace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFullscanphotosRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.apiFullscanphotosRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLabelfacesCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiLabelfacesCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FaceApi - object-oriented interface
 * @export
 * @class FaceApi
 * @extends {BaseAPI}
 */
export class FaceApi extends BaseAPI {
    /**
     * 
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesCreate(iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesCreate(iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesDestroy(id: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredCreate(iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredCreate(iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredDestroy(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListCreate(iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListDestroy(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IPatchedFaceList} [iPatchedFaceList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListRetrieve(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredListUpdate(id, iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IPatchedFace} [iPatchedFace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredPartialUpdate(id, iPatchedFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredRetrieve(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesInferredUpdate(id: string, iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesInferredUpdate(id, iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledCreate(iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledCreate(iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledDestroy(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListCreate(iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListDestroy(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IPatchedFaceList} [iPatchedFaceList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListRetrieve(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledListUpdate(id, iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IPatchedFace} [iPatchedFace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledPartialUpdate(id: string, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledPartialUpdate(id, iPatchedFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledRetrieve(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesLabeledUpdate(id: string, iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesLabeledUpdate(id, iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListCreate(iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListCreate(iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListDestroy(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListList(page?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IPatchedFaceList} [iPatchedFaceList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListPartialUpdate(id: string, iPatchedFaceList?: IPatchedFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListPartialUpdate(id, iPatchedFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListRetrieve(id: string, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {IFaceList} iFaceList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesListUpdate(id: string, iFaceList: IFaceList, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesListUpdate(id, iFaceList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this face.
     * @param {IPatchedFace} [iPatchedFace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesPartialUpdate(id: number, iPatchedFace?: IPatchedFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesPartialUpdate(id, iPatchedFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesRetrieve(id: number, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this face.
     * @param {IFace} iFace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFacesUpdate(id: number, iFace: IFace, options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFacesUpdate(id, iFace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiFullscanphotosRetrieve(options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiFullscanphotosRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FaceApi
     */
    public apiLabelfacesCreate(options?: AxiosRequestConfig) {
        return FaceApiFp(this.configuration).apiLabelfacesCreate(options).then((request) => request(this.axios, this.basePath));
    }
}
